/* Copyright 2010 ISD-team */
#include <string>
#include <vector>
#include <set>
#include <limits>

#include "./test.h"

const std::string S =
    "1000101100011111101011101111100001010101000100011000111110001011011010011"
    "0110001011001001010011000010001110110110110110000011000010110001101000111"
    "0010100000001001111010001101110001110011000100110000110010000110010011101"
    "0110101001011110100111110101010010101001100011110011100000011111001110011"
    "1111111001111010101010100111011101100100100001000100111111111011000010010"
    "0010010101010101101000011101111000000111010101011010000010110101111000010"
    "1100001011011000111000011111000100001110100000111000001110000110001101100"
    "0101110101100011101101000110101100100111110001111001100011101001100110000"
    "1100010110001010111110010110001011001010011101010001100111010110100010000"
    "0110111001100010000101001000100010011011011001101011111000111010000001001"
    "0010110001111111001111001111001101011111110110011101100010110101110101011"
    "0001100011101000100101001101001011111110111001000101101001011111111010110"
    "0100110100000000100010110001001110101011011111110110001100101101100010110"
    "1110110011101000111001011100000001000000111111110010110111101001011101111"
    "0000100001010100101100010101111011100011110000111010000101010101001001010"
    "1111010010011011001011011101111000000110111000111000110101111100111100110"
    "0110011001011000111101111101011101011111000100001010111001100010011111000"
    "1101011000010110111101101111100111110010111101000011111100101101001011100"
    "0000000111100101011101110000000101000010101010011000110111011011001000001"
    "0110010010100010000101010101111100111100000110111110000101001010110000011"
    "1110010011111110000010111001010100111110010110100100100010001000101110011"
    "1101110011100111100000101011100111110110110000100011101101001000101101111"
    "0001101100010111011010111111000011001110110101011101010011110100010111011"
    "0001101110111001010100001110110111000111000011110101101000001100000110000"
    "1010000101111101011111110011100001001010100101111100000111101110001010101"
    "1100111011110001001111000001011101011000111100001100011010101010001100101"
    "1010110110011100010100010000001111011100000011010111101100011101100010101"
    "1100110111000101100101001000101010001110100000111011001111010001000010011"
    "1110111010110101100000110111110111000011011011110101100001100000100011110"
    "0111001011000110011110010100110010110000100011111010000011010100101000010"
    "1111001111001001111011011101011110101100010110011011001111100100100000010"
    "0011100100000010010101000111110101010100101111010010000000100011101101100"
    "0010101011011110011001011100001101001101111001011111100110101011001010011"
    "1111111110000110010011101111010001101100011101001011000011001001010000111"
    "0000111001101101001001000001010101101010101100010000001110000101111111000"
    "1001001111111001001001110001101000010110000100101101010000100010010001010"
    "0101011001110111010111100100101010101110100101010011111010100111100110110"
    "1101001010100000001001100111001110110011000001101111011101001101110011101"
    "0100011111000111110010110101110111111001110001110010101101000000101111011"
    "0010111000111111001000100010011111111110111111101000010010011101001000010"
    "0010010101011011111000111000000010011010100111101010110011111110101000010"
    "0110101001001001000110011001101000100011010100000110111000111111001110100"
    "1010100000000111100101111110001010000110110111010010111100111001110111100"
    "1101001110011000001010011100011001110001101010011110000100001010110110000"
    "1100100011110111111101111100000010001100111111111100110110111010100000110"
    "0010010110000010100110001101011111101000000001011000110001110000000011100"
    "1011110101110000010010010010000100000010000011000011010011110110100111111"
    "1010011100110101111110101100110100111010001001000010110000010100011000001"
    "0101111110011111110100010010101010100111100101010100110110001001111001011"
    "0110011000110111110100000010110100101000001001000101111111101100100100100"
    "1010111001001010001100111000001010010010101111011100110000000011100010111"
    "1001001111100011001011101111110100110111110100111111001100000100001001101"
    "1101110111111110000111010100011110100110000001001110111001111101011101111"
    "1011011111110101111100010001100010001101100001011011110100011111010010001"
    "111111010110011001001111110";

const std::string expected =
    "0000001000000000000100000010000010001010101000110010110101001110000000000"
    "1001001000001100011100001100100100100110000100100010001000001100110000000"
    "0110001000000001000001000100";

const isd_parameters *param;

std::set< std::vector<unsigned long> > F;

void callback(unsigned long *w) {
  int size = isd_size_in_limbs(param->n);
  std::vector<unsigned long> found(size);
  for(int i = 0; i < size; i++)
    found[i] = w[i];
  F.insert(found);
}

int test(int px, int py) {
  ISD::Decoder CC;

  CC.SetSizes(174, 27);
  CC.SetSystematicMatrixFromString(174, 27, S);
  CC.SetParameter_w(47);
  CC.SetParameter_c(4);
  CC.SetParameter_px(px);
  CC.SetParameter_py(py);
  CC.SetParameter_l(8);
  CC.SetParameter_m(1);
  CC.SetParameter_r(3);
  CC.SetParameter_max_iteration(50000);
  CC.SetParameter_max_words(50);
  CC.SetParameter_callback(&callback);

  param = CC.parameters();

  CC.Run(NULL);

  if (F.size() != 1) {
    int Fsize = F.size();
    printf("expected: 1 obtained: %d\n", Fsize);
    printf("expected:\n%s\n", expected.c_str());
    printf("pbtained:\n");
    for (std::set< std::vector<unsigned long> >::iterator i = F.begin();
         i != F.end();
         ++i) {
      const unsigned long *word = &(*i)[0];
      std::string obtained(174, '0');
      for (int j = 0; j < 174; ++j)
        obtained[j] += isd_get_bit(word, j);
      printf("%s\n", obtained.c_str());
    }
    return 1;
  }

  const unsigned long *word = &(*F.begin())[0];

  std::string obtained(174, '0');
  for (int i = 0; i < 174; ++i)
    obtained[i] += isd_get_bit(word, i);

  if (obtained != expected) {
    printf("expected:\n%s\nobtained:\n%s\n(px = %d, py = %d)\n",
           expected.c_str(),
           obtained.c_str(),
           px, py);
    return 2;
  }
  return 0;
}

int test_p_is_1(void) {
  return test(1, 1);
}

int test_p_is_1_2(void) {
  return test(1, 2);
}

int test_p_is_2_1(void) {
  return test(2, 1);
}

int test_p_is_2(void) {
  return test(2, 2);
}

int test_p_is_3(void) {
  return test(3, 3);
}

int main(int argc, char *argv[]) {
  int res = 0;
  res |= DO(test_p_is_1);
  res |= DO(test_p_is_1_2);
  res |= DO(test_p_is_2_1);
  res |= DO(test_p_is_2);
  res |= DO(test_p_is_3);
  return res;
}
